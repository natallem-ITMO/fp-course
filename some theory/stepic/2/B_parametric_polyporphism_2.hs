module B_parametric_polyporphism_2 where
import Data.Function
{-
Функция компоизиции
Предположим
  f :: a -> b
  g :: c -> a
  x :: c
  f (g x) :: b
  Но функция \x -> f (g x) :: c -> b
-}
compose f g = \x -> f (g x)
{-
  :t compose
  - (t1 -> t) -> (t2 -> t1) -> t2 -> t

В хаскеле функция compose это (.)
  :i (.)
  - (.) :: (b -> c) -> (a -> b) -> a -> c   -- Defined in `GHC.Base'
  - infixr 9 .
В языке ассоциативность не важна(в данном случае парвая), т.к. по определению хаскеля композиция ассоциативна
Высокий приоритет!

В предыдущем уроке sumFstFst - пример композиции
-}
p1 = ((3,4),(1,24))
p2 = ((4,4),(214,24))
sumFstFst'' = (+) `on` (fst . fst) -- сократили выражение
{-цепочка последовательных применений фукнции может быть записана в помощью оператора композиции
doIt x = f ( g (h x))) =  f ( (g . h) x) = ( f . (g . h)) x  // и можем избавиться от x слева и справа
doIt  =  f . g . h
-}


{-Встроенные структуры, такие как списки и картежи тоже параметрически полиморфны
Списки имеют полиморфное поведение - в качетсве элемента можем использовать любой тип, и соответствующее значение будет появлятся соответсвующий тип
  :t [True, False]
  - [True, False] :: [Bool]
  :t "sdf"
  - "sdf" :: [Char]
  :t []
  - [] :: [a]

Такой же полиморфизм присутствует в функциях над списками
  :t (++)
  - (++) :: [a] -> [a] -> [a]
  :t (:)
  - (:) :: a -> [a] -> [a]

Степень полиморфизма картежей выше, чем у списков.
Альтернативный синтаксис постороения картежей:

естественно-префиксный стиль коструирования пары(стандартный стиль вызова функции)
  (,) True 3 // (,) отдельно стоящий конструктор картежа
  - (True, 3)
  (,,) True 's' 5
Миксфиксный стиль - обычный(перепутаны элементы структуры пары и вставляемые элементы)
  (True, 3)
  - (True, 3)

  :t (,)
  - (,) :: a -> b -> (a,b)
-}
dup = \x -> (x,x)
{-
  :t dup
  - dup :: t -> (t,t) //не до конца мономорфизировалась пара

Еще полиморфные функции картежей

  :t fst
  - fst :: (a,b) -> a

  :t snd
  - snd :: (a,b) -> b
-}

{-Идея частичного применения функции, когда аргументы могут передаваться по одному, придумал Хаскель Карри.
Такие функции(с аргументами, передающимся по одному) называются каррированными.

Но функции над картежами некаррированны
  fst (1,4)
  - 1
Каррирование - процедура перехода от некаррированых к каррированным функциям.
Например есть некарр. функция, но в функциях высшего порядка используется каррированная.

curry => function (x,y) -> function x y
uncurry => function x y -> function (x,y)

Например в `on`
-}
fstSqr = curry fst `on` (^2)
avg :: (Double, Double) -> Double
avg x = (fst x + snd x) / 2 -- not curried
{-
  :t fstSqr
  - fstSqr :: Integer -> Integer -> Integer

  :t curry avg `on` (^2)
  - curry avg `on` (^2) :: Double -> Double -> Double
-}
cur notCurried x y = notCurried(x,y) -- то, как устроена curry функция
{-
  :t curry
  - curry :: ((a,b) -> c) -> a -> b -> c

  :t uncurry
  - uncurry :: (a -> b -> c) -> (a, b) -> c

  curry id <=> (,)
-}

