module E_nonstrict_semantic where
{-
Вычисление в функциональных язык происходит по средством редукции, от порядка инструкций порядок вычисления не зависит
Вычисление функций с аргументами
1) Энергичная стратегия (в имеративных языках) - вычисляем все аргументы
2) Ленивая - подставляем в выражение и вычисляем (в хаскеле)
-}

sumIt :: Int -> Int -> Int
sumIt x y = x + y
{-
Ленивая:
  sumIt (1 + 2) 3
~>  (1 + 2) + 3
~>  3 + 3
~>  6

Энергичная:
  sumIt (1 + 2) 3
~>sumIt (3) 3
~> 3 + 3
~> 6

Редекс - выражение, которое может быть упрощено непосредственно
sumIt (1 + 2) 3 - два редекса
                  1 + 2
                  применение функции к аргументам (прямая подставновка)

Важное свойство чистых фукнциональных языков - независимость от выбранной стретегии, до тех пор пока программа является завершающейся
В имеративных языках это свойство не выполняется из-за наличия изменяемых переменных

id x = x
const x y = x
max x y = if x <= y then y else x
infixr 0 $
f $ x = f x
Сколько редексов имеется в следующем выражении
const $ const (4 + 5) $ max 42
      1          2    3
-}


{-
Полезные свойства ленивых вычислений : нет лишних вычислений параметров (иногда)
dup x = (x,x)
dup (2 + 3) // будет 2 лишних ленивых вычисления

func x y = x + 7
func 4 4+2 // будет лишнее вычисление при энергичной стратегии

Придуман механизм разделения, когда считаем используемую несколько раз переменную считаем 1 раз
при вычислении подставляется не выражение, а некоторый указатель

  dup (2+3)
~>(p, p) // p is (2+3), когда наступает очередь вычисления, то p=5
~>(5,5)
Механизм разделения - теперь вычисление выражения это не дерево, а граф
-}

bar x y z = x + y
foo a b = bar a a (a + b)
value = foo (3 * 10) (5 - 2)
{-
foo (3 * 10) (5 - 2) // a= 3 * 10 b=5 - 2
bar a a (a + b)
a + a
30 + 30
60
-}

{-
В рамках модели ленивых вычислений мы можем элиминировать расходимости
-}
const42 :: a -> Int
const42 = const 42
{-
  const42 undefined
  -42 // undefined не вычисляется и программа не падает

const42 - нестрогая функция
Нестрогая функция - если в аргумент передается расходящееся вычисление, а результат - значение нерасходящееся
Строгая функция - передали расходящийся аргумент, получили только расходящийся результат.

Фукнция от 2 аргументов может быть строй и не строгой по значению 2го аргумента в зависимости от значения первого
Анализ строгости/не строгости - нетревиальная задача
(+) sin и т.д. - строгие операции. Компилятор об этом знает. Может анализировать остальные фукнции из учета вызовы базовых.
Анализатор строгости позволяет оптимизировать программы
Энергичная модель эффективнее ленивой, т.к. не требует косвенности вызовов
Если компилятор понимает, что функция строгая, то заменяет ее вычисление на эффективную модель
-}

{-
Вычисление - процесс редкуции. Редукция просиходит до тех пор, пока в выражении есть редексы.

Нормальная форма - выражение в ней не содержит редексов, оно дошло до окончательного результата.
NF
42
(3,4)
\x -> x + 2

Not NF
"Real " ++ "world"
sin (pi / 2)
(\x -> x + 2) 5
(3, 1+5) // конструктор, примененный к значению, находящемуся в не NF

Слабая заголовочная нормальная форма
\x -> x + 2 * 3 // лямбда абстракция, вычисление находится за барьером лямбда абстракции(внутри тела лямбда функции)
(3, 1+5) // конструктор данных, пары, картежа и т.д.
(,) (4*5) // частичное применение конструктора
(+) (7^2) // частично примененная ВСТРОЕННАЯ фукнция, но наша фукнция в данном случае не была бы в слабой форме

СЗНФ покраывает выражения в НФ
Вычисление в хаскеле останавливаются в СЗНФ, не доводя их до нормальной формы(позволяет сделать функции еще более определенными в случае расходимости)
-}

{-
Иногда механизм ленивых вычислений может приводить к проблемам.
В результате обработки данных большого размера отложенные вычисления могут накопиться(например суммируем список - 10 млн чисел лежат в памяти, готовые к сложению)

Если мы обнаружили длинное отложенное вычисление, надо дать компилятору сигнал, чтобы он сделал вычисление.
Нужен оператор Seq
Вычислительный примитив. Нарушает ленивую семантику, если пользуемся им, то вычисления перестают быть ленивыми

seq :: a -> b -> b
seq _|_ b = _|_ // _|_ - основание, обозначает расходящееся вычисление. Оператор seq, если его первый аргумент расходится, то он тоже расходится, иначе возвращает второй аргумент
seq a b = b //equal to (flip const)
seq - встроенный примитив(его нельзя реализовать в хаскеле)

  seq 1 2
  -2

  seq undefined 2
  -***Exception: Prelude.undefined

  seq (id undefined) 2 // вычисление тоже приводит к расходимости
  -***Exception: Prelude.undefined

как глубоко seq форсирует вычисления? До слабой заголовочной нормальной формы
   seq (undefined, undefined) 2
   -2

   seq (\x -> undefined, 20
   -2
-}

{-
При вычислении каких из перечисленных ниже функций использование seq предотвратит нарастание количества невычисленных редексов при увеличении значения первого аргумента:
-}
foo 0 x = x
foo n x = let x' = foo (n - 1) (x + 1)
          in x' `seq` x'

bar 0 f = f
bar x f = let f' = \a -> f (x + a)
              x' = x - 1
          in f' `seq` x' `seq` bar x' f'

baz 0 (x, y) = x + y -- seq не уменьшит кол-во вычислений т.к. пара в p это конечное выражение в слабой заголовочной нормальной форме
baz n (x, y) = let x' = x + 1
                   y' = y - 1
                   p  = (x', y')
                   n' = n - 1
               in p `seq` n' `seq` baz n' p

quux 0 (x, y) = x + y -- seq уменьшит кол-во вычислений т.к. сначчала вычисляется то что перед seq, а потом возвращается значение после seq
--приоритет seq = 0, infixr
quux n (x, y) = let x' = x + 1
                    y' = y - 1
                    p  = (x', y')
                    n' = n - 1
                in x' `seq` y' `seq` n' `seq` quux n' p


{-
Опеределен оператор с вызовом по значению, который позволяет удобнее форсировать вычисления

seq :: a -> b -> b
seq _|_ b = _|_
seq a b = b

($!) :: (a -> b) -> a -> b
($!) f x = x `seq` f x // сначала вычисляется x, затем возвращается f x, x - предварительно приводится к слабой заголовочной нормальрной форме

  const 42 $! undefined
  -***Exception: Prelude.undefined
-}

factorial :: Integer -> Integer
factorial x | x < 0 = error "arg should be >= 0"
            | otherwise = helper 1 x
   where helper acc 0 = acc
    --helper acc n = helper (acc * n) (n-1) // не форсированное вычисление
         helper acc n = (helper $! (acc * n)) (n-1) -- форсированное, у $! приоритет 0, поэтому скобки
-}




