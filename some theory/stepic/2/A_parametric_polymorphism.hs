module A where
import Data.Function
{-Функция обладает полиморфным поведением, если она может быть вызвана на значениях разного типа
Например, сложение (вызываем на Int or Double)

Два типа полиморфных фунций
*Парметрический(код функции одинаков для всех типов)
*Специальный(для каждого допустимого типа есть своя реализация)
Сложение - специальный полиморфизм, т.к. на низком уровне это разный код.
-}

--Займемся параметрическим полиморфизмов:
id x = x --(параметрически полиморфна)
  {-
  :t id
  -id :: t -> t  // t-переменная тип(можно подставить любой тип)

  (id id) 4
  -4

  :t (id id)
  - (id id) :: t -> t //т.к. при применение функции ее арность уменьшается на единицу, т.е. из (t -> t) -> t -> t получаем t -> t
  -}
k t x = x
  {-
  :t k
  -k :: t1 -> t -> t1

  в стандартной библиотеке такая функция называется const
  :t const True
  -const True :: b -> True (т е это функция, которая всегда возращает переданный аргумент)

  :t undefined
  -undefined :: a (a - переменная типа, т.к. константа undefined подходит для любого типа, это следствие того, что она универсальная функция)
undefined подходит для любого типа, выражение всегда будет правильно типизировано.
Содержательная константа(которая содержит значение, а не прерывание из-за ошибки) не может иметь универсально-полиморфный тип a
Константа undefined населяет любой допустимый тип
error "dsf" тоже населяет любой тип(константа произвольного типа)
  :t error
  -error :: [Char] -> a
Эти дву фунции прерывают выполнение программы, но только с помощью таких объектов мы можем создавть программы наивысшей степени полиморфизма.
Такие фнукции с наивысшем полиморфизмом так как у них даже не стрелочный тип.
-}


{-Ограничим степени полиморфности функции, явно указав ее тип-}
mono :: Char -> Char
mono x = x -- ограничили тип

--частичное ограничение тип
semiMono :: Char -> a -> Char
semiMono x y = x -- полиморфна по 2ом аргументу, мономорфна по первому

{-Без указания типов хаскель выводит наиболее общий тип
Аппликативная структрура всего выражения в правой части задает набор уравнений
Каждое применение какого-то идентификатора к другому, хаскель может сказать следущее
Справа тип произвольный, а слева только стрелочный(применяем только функции)
Хаскель в процессе вывода типов строит некторую систему уравнений, разрешает ее наиболее общим обрзом.
(см. алгоритм Хиндли-Миллера - воводит самый общий тип)
-}


{-
Функции высших порядков - функция, принимающая в кач-ве аргмента другую функцию.
Функции высших порядков - например, сортировка в С языке.

Простейшая функция высшего порядка ($)
  :t ($)
  -($) :: (a -> b) -> a -> b
-}

apply2 f x = f (f x)
  {-
  :t apply2
  -(a -> a) -> a -> a
  -}
apply2wow x  = apply2 (++ ", wow") -- arg, wow, wow

--flip f x y = f y x

{-
  flip (/) 4 2
  -0.5

  flip const 4 True
  -True

  :t flip
  -flip :: (a -> b -> c) -> b -> a -> c

  :t (flip const)
  -(flip const) :: b -> a -> a
-}


{-
Функция on:
  из фукнции f типа (a->a->b) и функции g типа (c->a), 2х аргументов типа c получаем функцию типа (c->c->b), применняя g к обоим аргументам, а результаты к f
  :t on
  - (a-> a -> b) -> (c -> a) -> c -> c -> b
Функция перемножения вторых элементов в паре элементов
-}
multSecond = (*) `on` snd


{-
Анонимная функция
Обычно фукнции именнованы, для вызова обращаемся по имени.
2 * х + 7 - замкнутое выражение, получить значение нельзя
f x = 2 * x + 7 - объявление именнованной функции
Свяжем переменную х не с помощью объявления именнованной функции, а с помощью лямбда выражения
\x -> 2 * x + 7 - это тоже функция, не имеющая имени (лямбда-фукнция или анонимная)
  (\x -> 2 * x + 7) 5
  - 17
  f 5
  - 17
Объявим именнованную фукнции с помощью лямбда выражения
f' = \x -> 2 * x + 7
-}
lenVec = \x -> \y -> sqrt $ x^2 + y^2
lenVec' =  \x y -> sqrt $ x^2 + y^2 -- то же самое определение
--Применяются в функциях высших порядков, если нужно собрать передаваемую функцию по кусочкам(и нет именнованной функции)
--where можно юзать, но не так удобно и лаконично

--Пусть мы работаем с элементом "пара пар". Хотим функции суммирования первых элементов этих пар
sumFstFst = (+) `on` helper where
  helper pp = fst $ fst pp
sumFstFst' = (+) `on` \pp -> fst $ fst pp

p1 = ((3,4),(1,24))
p2 = ((4,4),(214,24))
{-
  sumFstFst' p1 p2
  - 7
-}





