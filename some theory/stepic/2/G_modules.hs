module E_nonstrict_semantic where
import  Data.Char
import  Data.List
import qualified Data.Set as Set -- qualified => все имена из этого модуля должны использоваться с префиксом
-- as => из-за иерархии имя длинное, тогда сокращаем (локальный псевдоним)
{-
Программа на языке представляет собой коллекцию модулей
Главный файл должен называться Main и содержать модуль Main
Каждый отдельный модуль находится в некотором файле с опр. именем и имя модуля должно совпадать с именем файла(может нарушаться, но не следует это делать)
Неявно импортируется модуль Prelude, для других функций надо импортить, все публичные функции будут доступны
указать список импорта (чтобы не импортить все)

import Data.Char (toUpper, toLower)

обратная задача, импорт всего кроме
import Data.Char hiding (toLower)

Нужно импортить функции одного имени из 2 модулей?
import Data.List
import Data.Set
  :t union
  -Top level:
    Ambiguous occurrence `union'
    It could refer to either `Data.List.union',//полное имя функции
                             imported from `Data.List' at G.hs:3:1-16
                          or `Data.Set.union',
                             imported from `Data.Set' at G.hs:4:1-15
                             (and originally defined in `containers-0.5.5.1:Data.Set.Base')

  :t union // берет из List
  union :: Eq a => [a] -> [a] -> [a]

  :t Set.union // используем локальный псевдоним
  - Set.union :: Ord a => Set.Set a -> Set.Set a -> Set.Set a
                      /модуль/конструктор/

import Prelude hiding (имя функции чтобы спрятать дефорл использование)
Явный импорт перекрывает те настройки, которые связаны с неявным импортом
-}


{-
Директива экспорта позволяет управлять доступом к нашему модулю
module MyModule (funcToExport1, funcToExport2) where
Директива экспорта - единственный способ инкапсуляции - сделать что то доступным на уровне модулей. Все, что не импортировали - доступно только внутри модуля.
При загрузке модуля загружаются все те модули, которые были в import(наши в т.ч.)
-}


{-
О компиляции .hs ->  исполняемая программа
Шаги
  1) Синтаксический разбор исходного кода, все имена становятся квалифицированными
  2) Проверка типа
  3) Рассахаривание - код транслируется в другой язык Коэр, не содержит многих синтаксических конструкций, преобразование в низкоуровневые конструкции, менее читабельно, но есть компиляторы, позволяющие читать такой код

  4) Несколько циклов модификации, код человекочетабелен
  5) Кодогенерация
      а) Преобразование в код СТГ машины(графовая машина, которая осуществляет графовую редукцию программы)
      б) Преобразование в язык С-- (похож на язык С, но более низкоуровневый)
  6) Кодогенерация настоящая - генерируем код для целевой платформы

-}




