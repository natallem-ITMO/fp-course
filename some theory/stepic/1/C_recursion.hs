module C_recursion where

{-
В фукнциональных языках циклы не осмысленны, т.к. нет понятия изменяемой переменной(не может отличить одну итерацию от другой)

Для повторяющихся вычислений используются рекурсивные функции, такие, что в правой части исползуется вызов самой функции.
Требования:
  * вызовы функции в правой части осуществляются на отличный от изначального параметра
  * терминирующее условие
-}

factorial n= if n == 0 then 1 else n * factorial (n-1)
{-при вычислении выражение редуцируется по определенным правилам до некоторой окончательной величины, которая не может быть редуцированна далее.
 Редуцирование - упрощение.
 -}


{-
Сопоставление с образцом(если if then else не удобно) - определяем фукнцию с помощью нескольких уравнений, каждое уравнение - возможная ветвь программы
-}
{-разница в описании параметра.-}
factorial' 0 = 1 -- 0 - образец, при вычислении фукнции происходит сопоставление с образцом. Параметр последовательно сравнивается с каждым образцом сверху вниз
factorial' n  = n * factorial' (n-1)--переменная - неопровержимый образец, сопоставление с которым всегда удачно. Фактический параметр свяжется в формальным параметром n, и этот формальный параметр сслыается на переданный фактический


{-
Что делать, если не те аргументы? Нужно прерывать программу(бесконечный цикл -  плохое решение)



Две фукнции:
  error "Exception message"
  -Exception: Exception message

  undefined
  -Exception: Prelude.undefined
-}
factorial'' 0 = 1
factorial'' n  = if n < 0 then error "Argument must be positive" else n * factorial' (n-1)--переменная - неопровержимый образец, сопоставление с которым всегда удачно. Фактический параметр свяжется в формальным параметром n, и этот формальный параметр сслыается на переданный фактический
{-С точки зрения статической семантики хаскеля, незавершающиеся рекурсии и прерывание программы из-за ошибки - неразличимы.
 В этом случае возращаемое значение программы - символ перевернутой Т - bottom. Это элемент любого типа в хаскеле. Может использоваться в любом месте программы.
 Используется так же при обозначении программ, где некоторые части не дописаны(т.к. компиляция осуществится)
 Еще undefined используют там, куда вычисление программы гарантированно не дойдет. Но если может дойти, лучше использовать error.
  -}


{-
Сопоставление с образцом не всегда подходит для описания подходящего ветвления.
Охранные выражения - позволяют расщипить одно уравнение на несколько, но не с помощью механизма сопоставления с образцом.
Охранное выражение - булево выражение, отделяющееся от параметров функции | .
При вызове если сопоставление с образцом удачное, то проверяется охранное выражение. Если истинно, то выполняется. Если ложно, то переходим к слудующему охранному выражению, или если таких нет, то к следующему образцу.
-}
factorial''' :: Integer -> Integer
factorial''' n | n == 0 = 1
               | n > 0 = n * factorial''' (n-1)
               | otherwise = error "Argument must be positive in factorial'''"


{-
Если нужна переменная, которая аккмулирует.
-}
factorial'''' x
  | x < 0 = error "arg should be >= 0"
  | otherwise = helper 1 x

helper acc x
  | x == 0 = acc
  | otherwise = helper (acc * x) (x-1)
{-GHCi позволяет отслеживать использование памяти и затраты времени на вычисление выражения, для этого следует выполнить команду :set +s:
  :set +s
  factorial''' 8000
  -(0.31 secs, 75337040 bytes)

  :set +s
  factorial' 8000
  -(0.45 secs, 77441072 bytes)
-}

fibonacci :: Integer -> Integer
fibonacci n | n == 0 = 0
            | n == 1 = 1
            | n > 0 = fib' n 1 0
            | n < 0 = fib'' n 0 1

fib' n acc1 acc2
  | n == 1 = acc1
  | otherwise = fib' (n-1) (acc1 + acc2) acc1

fib'' n acc1 acc2
  | n == 0 = acc1
  | otherwise = fib'' (n+1) (acc2 - acc1) acc1